#include <iostream>
#include <string>
#include <vector>

using std::string;
using std::vector;
using std::cin;
using std::cout;
using std::endl;

// пи-функция генерирует массив переходов
vector<int> piFunction(string img){
    vector<int> pi;
    pi.insert(pi.end(), 0); // первый символ образа имеет значение пи-функции равное нулю
    int i = 1; // счетчики
    int j = 0;
    while (i < img.size()){ // пока не дошли до конца строки первым счетчиком
        if (img[i] == img[j]){          // если символы на iом и jом месте равны,
            pi.insert(pi.end(), j + 1); // то добавляем в массив значений пи-функции j+1 (значение функции для символа на iом месте)
            i++;                        // увеличиваем счетчики
            j++;                        // и переходим к следующей итерации
        }
        else if (j == 0){               // если обнулился второй счетчик из-за следующего else-блока, но символы на iом и jом месте не равны
            pi.insert(pi.end(), 0);     // добавляем ноль в массив значений 
            i++;                        // продолжаем движение по строке 
        }
        else                            // если символы на iом и jом месте не равны и j не равно нулю,
            j = pi[j - 1];              // то значение вычисляется на основе уже существующего
    }
    return pi;
}

int kmp(string image, string haystack, vector<int> pi_vec) {
    if (image.size() != haystack.size()) // проверка на равенство длин
        return -1;
    int first_equal = -1;   // индекс первого совпадения после серии несовпадений
    int i_img = 0;             // индексы для первого и второго текста соответственно
    int i_hay = 0;
    bool loop = false;      // переменная для контроля зацикливания, false если еще ни разу не дошли до конца haystack
    while (true) {
        if (image[i_img] == haystack[i_hay]) {    // если два рассматриваемых символа совпадают 
            if (i_img == 0)                    // и это произошло впервые, то обновляем индекс первого совпадения
                first_equal = i_hay;
            i_img++;   // независимо от того в какой раз символы совпали продвигаемся вперед по обеим строкам
            i_hay++;
            if (i_img == image.size())  // если дошли до конца первой строки, значит нашли индекс во второй строке с которого началось совпадение
                return first_equal;     // возвращаем индекс первого совпадения
        }
        else if (i_img == 0){           //если символы не совпали но рассматриваем первую строку с самого начала
            i_hay++;                    // то продвигаемся по второй строке вперед
        }
        else{                           // если символы не совпали, но сравнивали уже не первый символ первой строки,
            i_img = pi_vec[i_img - 1];  // то в в ней переходим на символ с индексом равным предыдущему значению пи-функции
        }
        if(i_hay == haystack.size()){   // если дошли до конца второй строки
            if (loop)                   // дважды
                return -1;              // значит ничего не нашли
            loop = true;    // если в первый раз
            i_hay = 0;      // переходим в начало второй строки
        }
    }
}

int main() {
    string text1;   // первый текст как haystack
    string text2;   // второй текст как needle, образ
    cin >> text1;   
    cin >> text2;
    vector<int> pi = piFunction(text2);
    int answer = kmp(text2, text1, pi);
    cout << answer << endl;
    return 0;
}